/**
 * @file Firebase Security Rules for ReliefLink Firestore database.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for victims and volunteers,
 * where only the authenticated user or an admin can access their respective profiles.
 * Requests and Tasks are accessible based on user roles (victim, volunteer, admin)
 * and the state of the task/request.
 *
 * Data Structure:
 * - /victims/{victimId}: Stores victim profiles, accessible only by the victim or an admin.
 * - /volunteers/{volunteerId}: Stores volunteer profiles, accessible only by the volunteer or an admin.
 * - /requests/{requestId}: Stores requests, accessible based on the request status and user role.
 * - /tasks/{taskId}: Stores tasks, accessible based on the task status and user role.
 * - /admins/{adminId}: Stores admin UIDs. Existence in this collection grants admin privileges.
 *
 * Key Security Decisions:
 * - Listing of users (victims, volunteers, admins) is disallowed for non-admins.
 * - Data validation is relaxed to allow for rapid prototyping.
 * - Admin privileges are determined by the existence of a document in the /admins collection.
 * - Authorization Independence is achieved through denormalization, specifically by including relevant user roles or permissions directly within documents that require access control. This eliminates the need for complex `get()` calls in security rules, improving performance and security.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the current user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user is the owner of the document based on the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the current user is the owner of the existing document.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the current user is an admin by verifying their UID exists in the /admins collection.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    /**
     * @description Rules for the /victims collection.
     * @path /victims/{victimId}
     * @allow (read, write): if isOwner(victimId) || isAdmin()
     * @deny (read, write): if !isOwner(victimId) && !isAdmin()
     * @principle Enforces document ownership for reads and writes, allowing access only to the owner or an admin.
     */
    match /victims/{victimId} {
      allow get: if isOwner(victimId) || isAdmin();
      allow list: if false;

      allow create: if isOwner(victimId);
      allow update: if isExistingOwner(victimId) || isAdmin();
      allow delete: if isExistingOwner(victimId) || isAdmin();
    }

    /**
     * @description Rules for the /volunteers collection.
     * @path /volunteers/{volunteerId}
     * @allow (read, write): if isOwner(volunteerId) || isAdmin()
     * @deny (read, write): if !isOwner(volunteerId) && !isAdmin()
     * @principle Enforces document ownership for reads and writes, allowing access only to the owner or an admin.
     */
    match /volunteers/{volunteerId} {
      allow get: if isOwner(volunteerId) || isAdmin();
      allow list: if false;

      allow create: if isOwner(volunteerId);
      allow update: if isExistingOwner(volunteerId) || isAdmin();
      allow delete: if isExistingOwner(volunteerId) || isAdmin();
    }

    /**
     * @description Rules for the /requests collection.
     * @path /requests/{requestId}
     * @allow (read): if true
     * @allow (write): if isAdmin()
     * @deny (write): if !isAdmin()
     * @principle Allows public read access but restricts write access to admins only.
     */
    match /requests/{requestId} {
      allow get: if true;
      allow list: if isAdmin();

      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for the /tasks collection.
     * @path /tasks/{taskId}
     * @allow (read): if true
     * @allow (write): if isAdmin()
     * @deny (write): if !isAdmin()
     * @principle Allows public read access but restricts write access to admins only.
     */
    match /tasks/{taskId} {
      allow get: if true;
      allow list: if isAdmin();

      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for the /admins collection.
     * @path /admins/{adminId}
     * @allow (read, write): if isAdmin()
     * @deny (read, write): if !isAdmin()
     * @principle Restricts access to the /admins collection to only existing admins.
     */
    match /admins/{adminId} {
      allow get: if isAdmin();
      allow list: if false;

      allow create: if isAdmin();
      allow update: if false;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for the inventory collection. The user reported the original error here, indicating they don't have permission to list this collection.
     * @path /inventory
     * @allow (read): if isAdmin()
     * @allow (write): if false
     * @principle Restricts access to the /inventory collection to only existing admins.
     */
    match /inventory {
      allow get: if isAdmin();
      allow list: if isAdmin();

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}