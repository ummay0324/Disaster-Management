/**
 * @file Firestore Security Rules for ReliefLink
 * @core_philosophy This ruleset enforces a combination of ownership-based and role-based access control.
 * Users (victims and volunteers) primarily have access to their own data, while admins have broader access.
 * @data_structure Data is organized into top-level collections for victims, volunteers, requests, tasks, and admins.
 * Victim and Volunteer data are stored in documents keyed by their respective IDs under `/victims/{victimId}` and `/volunteers/{volunteerId}`.
 * Requests and Tasks are stored in `/requests/{requestId}` and `/tasks/{taskId}` respectively.
 * Admin status is determined by the existence of a document under `/admins/{adminId}`.
 * @key_security_decisions Listing of users (victims, volunteers, and admins) is disallowed for privacy reasons.
 * Admin privileges are granted based on the existence of a document in the `/admins/{adminId}` collection.
 * Authorization independence is achieved by including authorization-related data (e.g., `victimId` in requests) directly within documents.
 * @denormalization_for_authorization The `status` field in the `requests` collection enables efficient filtering of requests by status, avoiding complex security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the current user is signed in.
     * @returns {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user is the owner of the resource.
     * @param {string} userId - The user ID to compare against the request's auth UID.
     * @returns {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the current user is an existing owner of the resource.
     * @param {string} userId - The user ID to compare against the request's auth UID.
     * @returns {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the current user is an admin.
     * @returns {boolean} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    /**
     * @description Defines rules for the /victims/{victimId} collection.
     * @path /victims/{victimId}
     * @allow (read, write) if isOwner(victimId)
     * @deny (read, write) if !isSignedIn()
     * @principle Enforces document ownership for writes.
     */
    match /victims/{victimId} {
      allow get: if isOwner(victimId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(victimId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(victimId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(victimId);
    }

    /**
     * @description Defines rules for the /volunteers/{volunteerId} collection.
     * @path /volunteers/{volunteerId}
     * @allow (read, write) if isOwner(volunteerId)
     * @deny (read, write) if !isSignedIn()
     * @principle Enforces document ownership for writes.
     */
    match /volunteers/{volunteerId} {
      allow get: if isOwner(volunteerId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(volunteerId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(volunteerId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(volunteerId);
    }

    /**
     * @description Defines rules for the /requests/{requestId} collection.
     * @path /requests/{requestId}
     * @allow (read) if true
     * @allow (create) if isSignedIn()
     * @allow (update, delete) if isAdmin()
     * @principle Allows public read access, restricts write access to admins and the request owner.
     */
    match /requests/{requestId} {
      allow get: if true;
      allow list: if isAdmin();
      allow create: if isSignedIn();
      allow update: if isAdmin() || (isExistingOwner(resource.data.victimId) && request.resource.data.victimId == resource.data.victimId);
      allow delete: if isAdmin();
    }

    /**
     * @description Defines rules for the /tasks/{taskId} collection.
     * @path /tasks/{taskId}
     * @allow (read) if true
     * @allow (create) if isAdmin()
     * @allow (update, delete) if isAdmin()
     * @principle Allows public read access, restricts write access to admins.
     */
    match /tasks/{taskId} {
      allow get: if true;
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Defines rules for the /admins/{adminId} collection.
     * @path /admins/{adminId}
     * @allow (read, write) if isAdmin()
     * @deny (create) if !isOwner(adminId)
     * @principle Restricts access to admin documents to only existing admins.
     */
    match /admins/{adminId} {
      allow get: if isAdmin();
      allow list: if false;
      allow create: if isOwner(adminId) && request.resource.data.id == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

     match /alerts/{alertId} {
        allow get: if false;
        allow list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }
  }
}